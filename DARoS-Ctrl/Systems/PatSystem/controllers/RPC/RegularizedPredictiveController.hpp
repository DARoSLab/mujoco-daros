/*=====================Regularized Predictive Controller=======================*/
/*
 * Header file for the Regularized Predictive Controller class. Contains all of
 * the included outside libraries and classes. Defines the variables that
 * are to be used by the class.
 *
 * @author  Gerardo Bledt
 * @date    February 26, 2017
 * @version 0.5
 */
#ifndef REGULARIZEDPREDICTIVECONTROLLER_H
#define REGULARIZEDPREDICTIVECONTROLLER_H 

// IPOPT include
#include "IpTNLP.hpp"

// LCM include
#include <lcm/lcm-cpp.hpp>
#include "rpc_data_lcmt.hpp"
#include "rpc_outputs_lcmt.hpp"

// Baic Utilities
#include <iostream>
#include <math.h>
#include <ctime>
#include <iomanip>

// C++ Files generated by MATLAB
#include "RPC/RPCBounds.h"
#include "RPC/RPCConstraintJacobian.h"
#include "RPC/RPCConstraintJacobianFinal.h"
#include "RPC/RPCConstraintJacobianFinalSP.h"
#include "RPC/RPCConstraintJacobianSP.h"
#include "RPC/RPCConstraints.h"
#include "RPC/RPCConstraintsFinal.h"
#include "RPC/RPCCost.h"
#include "RPC/RPCCostGradient.h"
#include "RPC/RPCHeuristics.h"
#include "RPC/RPCInitialize.h"
#include "RPC/RPCLagrangianHessian.h"
#include "RPC/RPCLagrangianHessianFinal.h"
#include "RPC/RPCLagrangianHessianFinalSP.h"
#include "RPC/RPCLagrangianHessianSP.h"

using namespace std;
using namespace Ipopt;

// Constant parameters regardless of specific problem
static const int NUM_FEET = 4;
static const int NUM_STATES = 12;
static const int NUM_INPUTS = 24;
static const int NUM_DECISION_VARS = 36;
// {Dynamics} + {Foot on Ground} + {No Slip} + {Friction Pyramid} %+ {Kinematic Limits}
// NUM_STATES + NUM_FEET + 2*NUM_FEET + 4*NUM_FEET
static const int NUM_CONSTRAINTS = 44; //40
static const int NUM_PREDICTIONS = 5;
static const int NUM_PREDICTIONS_OUT = 5;
static const int NNZ_J_G = 300;//284;//258;
static const int NNZ_J_G_F = 40;  //
static const int NNZ_H = 135;//84;  // 482
static const int NNZ_H_F = 36;  // 482
static const int NUM_LCM_PRED_OUT = 8;


// Other implementations:

// Zero pitch / roll assumption
// static const int NNZ_J_G = 258;
// static const int NNZ_H = 84;

// Final step non zero constraints between steps
// static const int NNZ_J_G_F = 200;

// Cost function includes dynamics
// static const int NNZ_H = 482;
// static const int NNZ_H_F = 482;

/**
 * Class definition for the Regularized Predictive Controller.
 */
class RegularizedPredictiveController : public TNLP {
public:
  RegularizedPredictiveController();
  ~RegularizedPredictiveController() {};


  /* --------------------------RPC Methods------------------------- */

  // RPC functions (These should be moved to private eventually... maybe)
  void InitializeRPC(double* X_0);//
  void Bounds(double* X_ub, double* X_lb, double* constraints_ub, double* constraints_lb);
  double PredictedCost(const double* X);
  void Constraints(const double* X, double* constraints);
  void PredictedCostGradient(const double* X, double* gradient);
  void ConstraintJacobian(const double* X, double* constraint_jacobian);
  void LagrangianHessian(const double* X, double* hessian,
                         Number obj_factor, const Number* lambda);
  void GetPredictedTimeVector();
  void SetParameters();

  // Set Robot states
  void SetCurrentState(double* current_state_in);
  void SetFootLocations(double* p_foot_0_in);
  void SetHipLocations(double* r_hip_in);
  void SetDesiredTrajectory(double* x_d_in);

  // Set configuration variables
  //void SetNumPredictions(double NUM_PREDICTIONS_in);
  void SetStateWeights(double* Q_in);
  void SetInputRegularization(double* R_in);
  void SetHeuristicGains(double* K_ref_in);
  void SetRobotParameters(double mass_in, double* Inertia_in);
  void SetGaitParameters(double* enabled_in, double* phi_0_in, double* T_p_in, double* T_swing_in);
  void SetEnvironmentParameters(double* gravity_in, double* mu_in, double* z_g_in);
  void SetTimeStart(double time_start_in);
  void SetModifiedRegularization();

  // Get the final solution
  double GetSolution(int index);
  double GetStepLocation(int index);
  double GetSolutionTime(int index);
  double GetSolveTime();
  int CheckNewSolution();
  int GetSolved();
  void PublishDataLCM();
  void SetMutex(pthread_mutex_t solve_set_mutex);

  /* --------------------------IPOPT Methods-------------------------- */

  /**@name Overloaded from TNLP */
  //@{
  /** Method to return some info about the nlp */
  virtual bool get_nlp_info(Ipopt::Index& n, Ipopt::Index& m, Ipopt::Index& nnz_jac_g,
                            Ipopt::Index& nnz_h_lag, IndexStyleEnum& index_style);

  /** Method to return the bounds for my problem */
  virtual bool get_bounds_info(Ipopt::Index n, Number* x_l, Number* x_u,
                               Ipopt::Index m, Number* g_l, Number* g_u);

  /** Method to return the starting point for the algorithm */
  virtual bool get_starting_point(Ipopt::Index n, bool init_x, Number* x,
                                  bool init_z, Number* z_L, Number* z_U,
                                  Ipopt::Index m, bool init_lambda,
                                  Number* lambda);

  /** Method to return the objective value */
  virtual bool eval_f(Ipopt::Index n, const Number* x, bool new_x, Number& obj_value);

  /** Method to return the gradient of the objective */
  virtual bool eval_grad_f(Ipopt::Index n, const Number* x, bool new_x, Number* grad_f);

  /** Method to return the constraint residuals */
  virtual bool eval_g(Ipopt::Index n, const Number* x, bool new_x, Ipopt::Index m, Number* g);

  /** Method to return:
   *   1) The structure of the jacobian (if "values" is NULL)
   *   2) The values of the jacobian (if "values" is not NULL)
   */
  virtual bool eval_jac_g(Ipopt::Index n, const Number* x, bool new_x,
                          Ipopt::Index m, Ipopt::Index nele_jac,
                          Ipopt::Index* iRow, Ipopt::Index *jCol,
                          Number* values);

  /** Method to return:
   *   1) The structure of the hessian of the lagrangian (if "values" is NULL)
   *   2) The values of the hessian of the lagrangian (if "values" is not NULL)
   */
  virtual bool eval_h(Ipopt::Index n, const Number* x, bool new_x,
                      Number obj_factor, Ipopt::Index m, const Number* lambda,
                      bool new_lambda, Ipopt::Index nele_hess, Ipopt::Index* iRow,
                      Ipopt::Index* jCol, Number* values);

  //@}

  /** @name Solution Methods */
  //@{
  /** This method is called when the algorithm is complete so the TNLP can store/write the solution */
  virtual void finalize_solution(SolverReturn status,
                                 Ipopt::Index n, const Number* x,
                                 const Number* z_L, const Number* z_U,
                                 Ipopt::Index m, const Number* g,
                                 const Number* lambda, Number obj_value,
                                 const IpoptData* ip_data,
                                 IpoptCalculatedQuantities* ip_cq);
  //@}

private:
  // LCM parameters setup
  lcm::LCM * lcm;
  rpc_data_lcmt rpc_data, rpc_data_publish;

  int SOLVED = 0;
  pthread_mutex_t solve_mutex;

  // Hold the optimized variables
  double X_final[NUM_PREDICTIONS * NUM_DECISION_VARS] = {0};
  double dt_pred_final[NUM_PREDICTIONS] = {0};

  /* ---------------------Environment Parameters---------------------- */
  double gravity[3] = {0, 0, -9.81};                       // magnitude of gravity z
  double mu[NUM_FEET] = {0.75, 0.75, 0.75, 0.75};           // coefficient of friction
  double z_g[NUM_FEET] = {0, 0, 0, 0};            // ground height at foot locations
  double gravity_new[3] = {0, 0, -9.81};                       // magnitude of gravity z
  double mu_new[NUM_FEET] = {0.75, 0.75, 0.75, 0.75};        // coefficient of friction
  double z_g_new[NUM_FEET] = {0, 0, 0, 0};            // ground height at foot locations


  /* ------------------------Robot Parameters------------------------- */
  // Robot model parameters
  double mass_new = 42;
  double mass = 42;              // overall mass of the system
  double I_xx = 0.35;
  double I_yy = 2.1;
  double I_zz = 2.1;
  double Inertia_new[3] = {I_xx, I_yy, I_zz};
  double I_body_diagonal[3] = {I_xx, I_yy, I_zz};

  // Body 3D rigid box parameters of base body
  double body_length = 0.600;
  double body_width = 0.256;
  double body_height = 0.200;

  // Vector of distance from COM to each hip

  double r_hip_new[3 * NUM_FEET] = {0};
  double r_hip[3 * NUM_FEET] = {body_length / 2, -body_width / 2, -0 * body_height / 2,  // hip 1
                                body_length / 2, body_width / 2, -0 * body_height / 2,   // hip 2
                                -body_length / 2, -body_width / 2, -0 * body_height / 2, // hip 3
                                -body_length / 2, body_width / 2, -0 * body_height / 2   // hip 4
                               };

  // Initial foot locations, directly under hips on flat ground
  double p_foot_0_new[3 * NUM_FEET] = {0};
  double p_foot_0[3 * NUM_FEET] = {body_length / 2, -body_width / 2, 0, // foot 1
                                   body_length / 2, body_width / 2, 0,   // foot 2
                                   -body_length / 2, -body_width / 2, 0, // foot 3
                                   -body_length / 2, body_width / 2, 0   // foot 4
                                  };

  // Next step location
  double p_foot_f[3 * NUM_FEET] = {0};

  // Leg specific parameters
  double upper_leg_length = 0.34;//2;
  double lower_leg_length = 0.34;//5;
  double max_leg_length = upper_leg_length + lower_leg_length;

  // Desired state trajectory (should also be from LCM / calculated here)
  double current_state[NUM_STATES] = {0};
  double current_state_new[NUM_STATES] = {0};
  double x_d[NUM_PREDICTIONS * NUM_STATES] = {0};
  double x_d_new[NUM_PREDICTIONS * NUM_STATES] = {0};
  double x_ref[NUM_PREDICTIONS * NUM_STATES] = {0};
  double u_ref[NUM_INPUTS * NUM_PREDICTIONS] = {0};
  double H_X[NUM_PREDICTIONS * NUM_DECISION_VARS] = {0};


  /* -------------------------Gait Parameters------------------------- */
  // Vector of timesteps to take at each prediction
  double dt_pred[NUM_PREDICTIONS];

  // An extra row for the last prediction being unconstrained
  double contact_state_pred[NUM_FEET * (NUM_PREDICTIONS + 1)] = {0};

  // Hold when a new touchdown event occurs for the foot
  double touchdown_pred[NUM_FEET * NUM_PREDICTIONS] = {0};

  // The index of the next step
  int next_step[NUM_FEET] = {0};

  double x_touchdown[3 * NUM_FEET] = {0};

  // Get the gait data from LCM
  double phi_0[NUM_FEET] = {0};  // should eventually come from the robot
  double T_p[NUM_FEET] = {0};                    // should eventually come from the robot
  double T_swing[NUM_FEET] = {0};                // should eventually come from the robot
  double phi_0_new[NUM_FEET] = {0};              // should eventually come from the robot
  double T_p_new[NUM_FEET] = {0};                // should eventually come from the robot
  double T_swing_new[NUM_FEET] = {0};            // should eventually come from the robot
  double T_stance[NUM_FEET] = {0};
  double stance_fraction = 0;
  double flight_phase[NUM_PREDICTIONS] = {0};
  double enabled[NUM_FEET] = {0};
  double enabled_new[NUM_FEET] = {0};
  double s_Phi0[NUM_FEET * NUM_PREDICTIONS] = {0}; // phase of each foot at the start of timestep k
  double s_Phi1[NUM_FEET * NUM_PREDICTIONS] = {0}; // phase of each foot at the start of timestep k
  double lifted_foot[NUM_FEET * NUM_PREDICTIONS] = {0};

  /* ------------------Max and min values for states------------------ */

  // Position min and max
  double x_min = -10000, x_max = 10000;
  double y_min = -10000, y_max = 10000;
  double z_min = 0.05, z_max = 2.5;

  // Velocity min and max
  double dx_min = -10, dx_max = 10;
  double dy_min = -10, dy_max = 10;
  double dz_min = -10, dz_max = 10;

  // Rotation min and max
  double roll_min = -M_PI,  roll_max = M_PI;
  double pitch_min = -M_PI, pitch_max = M_PI;
  double yaw_min = -2 * M_PI,     yaw_max = 2 * M_PI;

  // Angular Velocity min and max
  double omega_x_min = -15, omega_x_max = 15;
  double omega_y_min = -15, omega_y_max = 15;
  double omega_z_min = -15, omega_z_max = 15;

  // Collect the initial mins and maxs in vectors
  double states_min[NUM_STATES] = {x_min, y_min, z_min, roll_min, pitch_min, yaw_min,
                                   dx_min, dy_min, dz_min, omega_x_min, omega_y_min, omega_z_min
                                  };
  double states_max[NUM_STATES] = {x_max, y_max, z_max, roll_max, pitch_max, yaw_max,
                                   dx_max, dy_max, dz_max, omega_x_max, omega_y_max, omega_z_max
                                  };

  /* ------------------Max and min values for inputs------------------ */

  // Force max and min
  double f_z_min = 5,             f_z_max = 650;
  double f_x_min = -mu[0] * f_z_max, f_x_max = mu[0] * f_z_max;
  double f_y_min = -mu[0] * f_z_max, f_y_max = mu[0] * f_z_max;

  // Maximum leg length
  double max_leg_length_x = 0.4, max_leg_length_y = 0.4;
  double max_leg_length_z = 0.6, max_leg_height = 0.05;
  double r_x_min = -max_leg_length_x, r_x_max = max_leg_length_x;
  double r_y_min = -max_leg_length_y, r_y_max = max_leg_length_y;
  double r_z_min = -(max_leg_length_z), r_z_max = max_leg_height;               // don't raise leg higher than body


  // Collect the initial mins and maxs in vectors
  double inputs_min[NUM_INPUTS] = {r_x_min, r_y_min, r_z_min, f_x_min, f_y_min, f_z_min,
                                   r_x_min, r_y_min, r_z_min, f_x_min, f_y_min, f_z_min,
                                   r_x_min, r_y_min, r_z_min, f_x_min, f_y_min, f_z_min,
                                   r_x_min, r_y_min, r_z_min, f_x_min, f_y_min, f_z_min
                                  };
  double inputs_max[NUM_INPUTS] = {r_x_max, r_y_max, r_z_max, f_x_max, f_y_max, f_z_max,
                                   r_x_max, r_y_max, r_z_max, f_x_max, f_y_max, f_z_max,
                                   r_x_max, r_y_max, r_z_max, f_x_max, f_y_max, f_z_max,
                                   r_x_max, r_y_max, r_z_max, f_x_max, f_y_max, f_z_max
                                  };

  double inputs_min_0[NUM_INPUTS] = {r_x_min, r_y_min, r_z_min, f_x_min, f_y_min, f_z_min,
                                     r_x_min, r_y_min, r_z_min, f_x_min, f_y_min, f_z_min,
                                     r_x_min, r_y_min, r_z_min, f_x_min, f_y_min, f_z_min,
                                     r_x_min, r_y_min, r_z_min, f_x_min, f_y_min, f_z_min
                                    };
  double inputs_max_0[NUM_INPUTS] = {r_x_max, r_y_max, r_z_max, f_x_max, f_y_max, f_z_max,
                                     r_x_max, r_y_max, r_z_max, f_x_max, f_y_max, f_z_max,
                                     r_x_max, r_y_max, r_z_max, f_x_max, f_y_max, f_z_max,
                                     r_x_max, r_y_max, r_z_max, f_x_max, f_y_max, f_z_max
                                    };

  /* ------------------------RPC Parameters------------------------ */

  // Heuristic weightings: 1-5 step, 6-10 force
  double K_ref[30] = {0};
  double K_ref_new[30] = {0};//{1.0, 2.0, 1.0, 1.0, 0.0,
  //1.0, 0.0, 0.0, 0.0, 0.0
  //};

  // State Weightings: Q
  double Q_x = 0,       Q_y = 0,       Q_z = 5000;
  double Q_dx = 2500,      Q_dy = 2500,      Q_dz = 2500;
  double Q_roll = 500,    Q_pitch = 1000,   Q_yaw = 2500;
  double Q_omega_x = 2.5, Q_omega_y = 2.5, Q_omega_z = 300;

  // Pack the vector corresponding to the diagonal elements of Q
  double Q_new[NUM_STATES] = {Q_x, Q_y, Q_z, Q_roll, Q_pitch, Q_yaw,
                              Q_dx, Q_dy, Q_dz, Q_omega_x, Q_omega_y, Q_omega_z
                             };
  double Q[NUM_STATES * NUM_PREDICTIONS] = {0};

  // Input Weightings: R
  double R_r_x = 350, R_r_y = 350, R_r_z = 350;
  double R_f_x = 0.25, R_f_y = 0.25, R_f_z = 0.001;

  // Pack the vector corresponding to the diagonal elements of R
  double R_new[NUM_INPUTS] = {R_r_x, R_r_y, R_r_z, R_f_x, R_f_y, R_f_z,
                              R_r_x, R_r_y, R_r_z, R_f_x, R_f_y, R_f_z,
                              R_r_x, R_r_y, R_r_z, R_f_x, R_f_y, R_f_z,
                              R_r_x, R_r_y, R_r_z, R_f_x, R_f_y, R_f_z
                             };
  double R[NUM_INPUTS * NUM_PREDICTIONS] = {0};

  /* -------------------------Index Tracking-------------------------- */
  // Keep track of vector index
  int i_X = 0;
  int i_x = 0;
  int i_u = 0;
  int i_H_X = 0;
  int i_xd = 0;
  int i_xref = 0;
  int i_uref = 0;
  int i_c = 0;
  int i_lf = 0;
  int i_g = 0;
  int i_jc = 0;
  int i_h = 0;
  int i_f = 0;
  int i_x1 = 0;
  int i_u1 = 0;
  int i_f1 = 0;
  int i_Q = 0;
  int i_R = 0;


  double time_start_new = 0.0;
  double time_start = 0.0;
  std::clock_t clock_timer;
  int NEW_SOLUTION = 1;


  //@{
  //  HS071_NLP();
  RegularizedPredictiveController(const RegularizedPredictiveController&);
  RegularizedPredictiveController& operator=(const RegularizedPredictiveController&);
  //@}

};
#endif
