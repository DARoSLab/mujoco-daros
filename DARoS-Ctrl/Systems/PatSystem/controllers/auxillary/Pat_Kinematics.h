/*! @file MCKinematics.h
 *  @brief Kinematics functions generated by matlab
 *
 */

#ifndef H_KINEMATICS
#define H_KINEMATICS

#include <cmath>
#include <iostream>
#include <type_traits>
#include <time.h>       /* clock_t, clock, CLOCKS_PER_SEC */

#include "cppTypes.h"
#include <utils/Utilities/Mathutilities.h>
#include <math.h>
#include <utils/Utilities/pseudoInverse.h>
#include <dynamics/FloatingBaseModel.h>
#include <robots/PatBiped.h>
#include <can_data_lcmt.hpp>

template <typename T>
class Pat_Kinematics {
 public:
   Pat_Kinematics(PatBiped<T>* pat, T max_iter, T tolerance);
   ~Pat_Kinematics(){};

   FBModelState<T> _state;

   DVec<T> IK(Vec3<T>p, DVec<T> q0,int linkid, Vec3<T> pos_ankle);
   DVec<T> IK_Jt(Vec3<T>p, DVec<T> q0,int linkid, Vec3<T> rel_pos);
   void UpdateModel(DVec<T> joint_angles, int linkid, int Nbjoint);
   void UpdateModel(int leg, DVec<T> &q, DVec<T> &qd);
   Vec3<T> FK(int linkid, Vec3<T> pos_ankle);
   D3Mat<T> Jlink(int linkid, int Nbjoint, Vec3<T> pos_ankle);

   void FK(int leg, Vec3<T>* pos);
   void UpdateModel(const can_data_lcmt* canData);
   void getFootPos(int leg, Vec3<T>* pos);
   void getFootVelocity(int leg, Vec3<T>* vel);
   void getLegJacobian(int leg, DMat<T>* J);
   void computeFootPosVelJacobian(int leg, Vec3<T>* pos, Vec3<T>* vel, DMat<T>* J);

 private:
   int getNumJoints(int linkid);


   // model to to Forward/inverse Kinematics
   FloatingBaseModel<T> _model;

   T  _tolerance;
   T  _max_iter;

};

#endif  // H_KINEMATICS
