/*! @file PatBipedKinematics.h
 *  @brief Kinematics functions generated by matlab
 *
 */

#ifndef GUIDE_DOG_KINEMATICS
#define GUIDE_DOG_KINEMATICS

#include <cmath>
#include <iostream>
#include <type_traits>

#include "cppTypes.h"
#include <utils/Utilities/Mathutilities.h>
#include <robots/PatBiped.h>
#include <math.h>
#include <controllers/auxillary/PatForwardKinematics.h>
#include <utils/Utilities/pseudoInverse.h>

namespace PatKinematics
{

  /*!
 * Given bipedruped model, joints q, and leg index
 * Returns foot position in the robot hip frame
 */
/*
  template <typename T>
  Vec3<T> fkFoot(PatBiped<T> &biped, Vec3<T> q, int leg)
  {
    // Vec3<T> fkFoot(Vec3<T> q, int leg){
    Vec3<T> pFoot;

    //Code from LegController.cpp
    T l1 = biped._abadLinkLength;
    T l2 = biped._hipLinkLength;
    T l3 = biped._kneeLinkLength;
    T l4 = biped._kneeLinkY_offset;
    T sideSign = biped.getSideSign(leg);

    T s1 = std::sin(q(0));
    T s2 = std::sin(q(1));
    T s3 = std::sin(q(2));

    T c1 = std::cos(q(0));
    T c2 = std::cos(q(1));
    T c3 = std::cos(q(2));

    T c23 = c2 * c3 - s2 * s3;
    T s23 = s2 * c3 + c2 * s3;

    pFoot[0] = l3 * s23 + l2 * s2;
    pFoot[1] = (l1 + l4) * sideSign * c1 + l3 * (s1 * c23) + l2 * c2 * s1;
    pFoot[2] = (l1 + l4) * sideSign * s1 - l3 * (c1 * c23) - l2 * c1 * c2;
    return pFoot;
  }*/

  /*!
 * Given bipedruped model, joints q, and leg index
 * Returns knee position in the robot hip frame
 */
/*
  template <typename T>
  Vec3<T> fkKnee(PatBiped<T> &biped, Vec3<T> q, int leg)
  {
    Vec3<T> pKnee;

    //Code from LegController.cpp
    T l1 = biped._abadLinkLength;
    T l2 = biped._hipLinkLength;
    T l3 = biped._kneeLinkLength;
    T l4 = biped._kneeLinkY_offset;
    T sideSign = biped.getSideSign(leg);

    T s1 = std::sin(q(0));
    T s2 = std::sin(q(1));
    T s3 = std::sin(q(2));

    T c1 = std::cos(q(0));
    T c2 = std::cos(q(1));
    T c3 = std::cos(q(2));

    T c23 = c2 * c3 - s2 * s3;
    T s23 = s2 * c3 + c2 * s3;

    pKnee[0] = l2 * s2;
    pKnee[1] = (l1 + l4) * sideSign * c1 + l2 * c2 * s1;
    pKnee[2] = (l1 + l4) * sideSign * s1 - l2 * c1 * c2;
    return pKnee;
  }
  */

  /*template <typename T>
  Mat3<T> JFoot(PatBiped<T> &biped, Vec3<T> q, int leg)
  {
    Mat3<T> J;
    T l1 = biped._abadLinkLength;
    T l2 = biped._hipLinkLength;
    T l3 = biped._kneeLinkLength;
    T l4 = biped._kneeLinkY_offset;
    T sideSign = biped.getSideSign(leg);

    T s1 = std::sin(q(0));
    T s2 = std::sin(q(1));
    T s3 = std::sin(q(2));

    T c1 = std::cos(q(0));
    T c2 = std::cos(q(1));
    T c3 = std::cos(q(2));

    T c23 = c2 * c3 - s2 * s3;
    T s23 = s2 * c3 + c2 * s3;

    J(0, 0) = 0;
    J(0, 1) = l3 * c23 + l2 * c2;
    J(0, 2) = l3 * c23;
    J(1, 0) = l3 * c1 * c23 + l2 * c1 * c2 - (l1 + l4) * sideSign * s1;
    J(1, 1) = -l3 * s1 * s23 - l2 * s1 * s2;
    J(1, 2) = -l3 * s1 * s23;
    J(2, 0) = l3 * s1 * c23 + l2 * c2 * s1 + (l1 + l4) * sideSign * c1;
    J(2, 1) = l3 * c1 * s23 + l2 * c1 * s2;
    J(2, 2) = l3 * c1 * s23;

    return J;
  }*/

  /*!
 * Given bipedruped model, relative foot position, and leg index
 * Returns joints q1,q2,q3
 */
  template <typename T>
  Vec3<T> ikFoot(PatBiped<T> &biped, Vec3<T> p, Vec3<T> q0, int leg)
  {
    Vec3<T> q, dq, e;
    Mat3<T> J;
    DMat<T> JD, J_ps;
    JD.resize(3, 3);
    int iter = 0;

    //Find qd st f(q)=X-f(qd)=0
    //Uses Newton-Raphson method
    T tolerance = .01; //1 cm
    double sigma_thresh = .01;
    //Initial guess
    q = q0;
    e = p - fkFoot(biped, q, leg); //error vector
    // std::cout<<"Leg: "<<leg<<"  Iter: "<<iter<<"  Error: "<<e.norm()<<"\n";

    if (e.norm() > biped._abadLinkLength + biped._hipLinkLength + biped._kneeLinkLength)
    {                                                                    //position is out of bounds
      throw std::invalid_argument("Relative position is out of bounds"); //raise error
      std::cout << "Leg: " << leg << "  Error: " << e.norm() << "\n";
    }
    while (e.norm() > tolerance && iter < 5)
    {                           //while the error distance is smaller than some tolerance
      J = JFoot(biped, q, leg); //Mat3
      //Copy Mat3 into DMat
      for (int i = 0; i < 3; i++)
      {
        for (int j = 0; j < 3; j++)
        {
          JD.coeffRef(i, j) = J(i, j);
        }
      }
      pseudoInverse(JD, sigma_thresh, J_ps); //Compute J_ps
      dq = J_ps * e;
      q += dq; //calculate new q (Matrix Vector Multiplication)
      e = p - fkFoot(biped, q, leg);

      //Print useful info
      // std::cout<<"Leg: "<<leg<<"  Iter: "<<iter<<" dq: "<<dq<<"  Error: "<<e.norm()<<"\n";
      iter++;
    }
    return q;
  }

  //Forward kinematics from Matlab
  Vec3<float> fkFootMatlab(Vec3<float> in1)
  {
    Vec3<float> pFoot;
    float t2;
    float t3;
    float t4;
    float t5;
    float t6;
    float t7;
    float t8;
    float t9;
    float t10;
    float t11;
    float t12;
    float t14;
    float t15;
    float t16;
    float t17;
    float t19;
    float t20;
    float t32;
    float t40;
    float t51;
    float t52;
    float t55;
    float t53;
    float t54;
    float t56;
    float t58;
    t2 = cos(in1[0]);
    t3 = cos(in1[1]);
    t4 = cos(in1[2]);
    t5 = sin(in1[0]);
    t6 = sin(in1[1]);
    t7 = sin(in1[2]);
    t8 = t3 * t4;
    t9 = t3 * t7;
    t10 = t4 * t6;
    t11 = t6 * t7;
    t12 = t5 * t11;
    t14 = t2 * t8;
    t15 = t2 * t9;
    t16 = t2 * t10;
    t17 = t5 * t8;
    t19 = t5 * t9;
    t20 = t5 * t10;
    t32 = t9 + t10;
    t40 = t8 + -t11;
    t51 = t15 + t16;
    t52 = t19 + t20;
    t55 = t9 * 0.066 + t10 * 0.066;
    t53 = t14 + t2 * -t11;
    t54 = t12 + -t17;
    t56 = t8 * 0.066 + -(t11 * 0.066);
    t8 = (t8 * 0.195 + t3 * 0.209) + -(t11 * 0.195);
    t58 = (t2 * t7 * 0.209 + t19 * 0.066) + t20 * 0.066;
    t3 = (t15 * 0.066 + t16 * 0.066) + -(t5 * t7 * 0.209);
    t10 = ((t2 * 0.195 + t2 * t4 * 0.209) + t17 * 0.066) + -(t12 * 0.066);
    t9 = ((t5 * 0.195 + t4 * t5 * 0.209) + t2 * t11 * 0.066) + -(t14 * 0.066);
    pFoot[0] = ((((t2 * ((t15 * 0.195 + t16 * 0.195) + t2 * t6 * 0.209) * -0.5 -
                   t5 * ((t19 * 0.195 + t20 * 0.195) + t5 * t6 * 0.209) / 2.0) -
                  t51 * t10 / 2.0) +
                 t53 * t58 / 2.0) -
                t52 * t9 / 2.0) +
               t54 * t3 / 2.0;
    pFoot[1] = (((t5 * t8 / 2.0 - t32 * t3 / 2.0) + t40 * t9 / 2.0) - t51 * t55 /
                                                                          2.0) -
               t53 * t56 / 2.0;
    pFoot[2] = (((t2 * t8 * -0.5 - t32 * t58 / 2.0) - t40 * t10 / 2.0) - t52 * t55 / 2.0) + t54 * t56 / 2.0;
    return pFoot;
  }
}
#endif // PatBiped_KINEMATICS
